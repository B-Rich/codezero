#
# User space application build script
#
# Copyright (C) 2007 Bahadir Balban
#
import os
import sys
import shutil
from os.path import join
from glob import glob

task_name = "fs0"

# The root directory of the repository where this file resides:
project_root = "../.."
tools_root = join(project_root, "tools")
prev_image = join(project_root, "tasks/mm0/mm0.axf")
libs_path = join(project_root, "libs")
ld_script = "include/linker.lds"
physical_base_ld_script = "include/physical_base.lds"

# libc paths:
libc_variant = "userspace"
libc_libpath = join(libs_path, "c/build/%s" % libc_variant)
libc_incpath = join(libc_libpath, "include")
libc_crt0 = join(libs_path, "c/build/crt/sys-userspace/arch-arm/crt0.o")
libc_name = "c-%s" % libc_variant

#libmem paths:
libmem_path = "../libmem"
libmem_incpath = "../libmem"

# libl4 paths:
libl4_path = "../libl4"
libl4_incpath1 = join(libl4_path, "include")

# kernel paths:
kernel_incpath = join(project_root, "include")

# If crt0 is in its library path, it becomes hard to link with it.
# For instance the linker script must use an absolute path for it.
def copy_crt0(source, target, env):
	os.system("cp " + str(source[0]) + " " + str(target[0]))

def get_physical_base(source, target, env):
	os.system(join(tools_root, "pyelf/readelf.py --first-free-page " + \
		  prev_image + " >> " + physical_base_ld_script))

# The kernel build environment:
env = Environment(CC = 'arm-none-linux-gnueabi-gcc',
		  # We don't use -nostdinc because sometimes we need standard headers,
		  # such as stdarg.h e.g. for variable args, as in printk().
		  CCFLAGS = ['-g', '-nostdlib', '-ffreestanding', '-std=gnu99', '-Wall', '-Werror'],
		  LINKFLAGS = ['-nostdlib', '-T' + ld_script, "-L" + libc_libpath, "-L" + libl4_path,\
			       "-L" + libmem_path],
		  ASFLAGS = ['-D__ASSEMBLY__'],
		  PROGSUFFIX = '.axf',			# The suffix to use for final executable
		  ENV = {'PATH' : os.environ['PATH']},	# Inherit shell path
		  LIBS = [libc_name, 'gcc', 'libmc', 'libl4', 'gcc', libc_name],
		  CPPFLAGS = "-D__USERSPACE__",
		  CPPPATH = ['#include', libl4_incpath1, kernel_incpath, libc_incpath, libmem_incpath])

src = [glob("src/*.c"), glob("*.c"), glob("src/arch/arm/*.c"), glob("src/memfs/*.c"), glob("src/lib/*.c")]
objs = env.Object(src)
physical_base = env.Command(physical_base_ld_script, prev_image, get_physical_base)
crt0_copied = env.Command("crt0.o", libc_crt0, copy_crt0)

task = env.Program(task_name, objs + [crt0_copied])
env.Alias(task_name, task)
env.Depends(task, physical_base)
