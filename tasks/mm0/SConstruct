#
# User space application build script
#
# Copyright (C) 2007 Bahadir Balban
#
import os
import sys
import shutil
from string import split
from os.path import join
from glob import glob

task_name = "mm0"

# The root directory of the repository where this file resides:
project_root = "../.."
tools_root = join(project_root, "tools")
prev_image = join(project_root, "build/start.axf")
libs_path = join(project_root, "libs")
ld_script = "include/linker.lds"
physical_base_ld_script = "include/physical_base.lds"

# libc paths:
libc_variant = "userspace"
libc_libpath = join(libs_path, "c/build/%s" % libc_variant)
libc_incpath = join(libc_libpath, "include")
libc_crt0 = join(libs_path, "c/build/crt/sys-userspace/arch-arm/crt0.o")
libc_name = "c-%s" % libc_variant

# libl4 paths:
libl4_path = "../libl4"
libl4_incpath = join(libl4_path, "include")

# libposix paths:
libposix_path = "../libposix"
libposix_incpath = join(libposix_path, "include")

#libmem paths:
libmem_path = "../libmem"
libmem_incpath = "../libmem"

# kernel paths:
kernel_incpath = join(project_root, "include")

# Kernel config header.
config_h = join(project_root, "include/l4/config.h")


# If crt0 is in its library path, it becomes hard to link with it.
# For instance the linker script must use an absolute path for it.
def copy_crt0(source, target, env):
	os.system("cp " + str(source[0]) + " " + str(target[0]))

def get_physical_base(source, target, env):
	os.system(join(tools_root, "pyelf/readelf.py --first-free-page " + \
		  prev_image +" >> " + physical_base_ld_script))

# The kernel build environment:
env = Environment(CC = 'arm-none-linux-gnueabi-gcc',
		  # We don't use -nostdinc because sometimes we need standard headers,
		  # such as stdarg.h e.g. for variable args, as in printk().
		  CCFLAGS = ['-g', '-nostdlib', '-ffreestanding', '-std=gnu99', '-Wall', '-Werror' ],
		  LINKFLAGS = ['-nostdlib', '-T' + ld_script, "-L" + libc_libpath, "-L" + libl4_path, "-L" + libmem_path],
		  ASFLAGS = ['-D__ASSEMBLY__'],
		  PROGSUFFIX = '.axf',			# The suffix to use for final executable
		  ENV = {'PATH' : os.environ['PATH']},	# Inherit shell path
		  LIBS = [libc_name, 'libl4', 'libmm', 'libmc', 'libkm', \
		  'gcc', libc_name],		# libgcc.a - This is required for division routines.
		  CPPFLAGS = "-D__USERSPACE__",
		  CPPPATH = ['#include', libl4_incpath, libc_incpath, kernel_incpath, \
		  libmem_incpath, libposix_incpath])

def extract_arch_subarch_plat(config_header):
	'''
	From the autogenerated kernel config.h, extracts platform, archictecture,
	subarchitecture information. This is used to include the relevant headers
	from the kernel directories.
	'''
	arch = None
	subarch = None
	plat = None

	if not os.path.exists(config_header):
		print "\n\nconfig.h does not exist. "\
		      "Please run: `scons configure' first\n\n"
		sys.exit()
	f = open(config_h, "r")
	while True:
		line = f.readline()
		if line == "":
			break
		parts = split(line)
		if len(parts) > 0:
			if parts[0] == "#define":
				if parts[1] == "__ARCH__":
					arch = parts[2]
			   	elif parts[1] == "__PLATFORM__":
					plat = parts[2]
			   	elif parts[1] == "__SUBARCH__":
					subarch = parts[2]
	f.close()
	if arch == None:
		print "Error: No config symbol found for architecture"
		sys.exit()
	if subarch == None:
		print "Error: No config symbol found for subarchitecture"
		sys.exit()
	if plat == None:
		print "Error: No config symbol found for platform"
		sys.exit()
	return arch, subarch, plat

def create_symlinks(arch):
	arch_path = "include/arch"
	arch_path2 ="src/arch"
	if os.path.exists(arch_path):
		os.system("rm %s" % (arch_path))
	os.system("ln -s %s %s" % ("arch-" + arch, arch_path))
	if os.path.exists(arch_path2):
		os.system("rm %s" % (arch_path2))
	os.system("ln -s %s %s" % ("arch-" + arch, arch_path2))

arch, subarch, plat = extract_arch_subarch_plat(config_h)

create_symlinks(arch) # Creates symlinks to architecture specific directories.

src = [glob("src/*.c"), glob("src/lib/*.c"), glob("*.c"), glob("src/arch/*.c")]
objs = env.Object(src)
physical_base = env.Command(physical_base_ld_script, prev_image, get_physical_base)
crt0_copied = env.Command("crt0.o", libc_crt0, copy_crt0)

task = env.Program(task_name, objs + [crt0_copied])
env.Alias(task_name, task)
env.Depends(task, physical_base)

