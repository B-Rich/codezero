
		Codezero Microkernel 'Toy' release

		Copyright (C) 2007, 2008 Bahadir Balban


What is Codezero?

Codezero is a new microkernel that has been developeed around the L4 microkernel
design principles. It implements its own interpretation of the L4 microkernel
API. In addition, it provides server tasks that implement memory management, a
virtual filesystem layer, and these servers currently support a small but
essential subset of the POSIX API.

Codezero project is an effort to develop a modern, open source operating system
based on the latest technology in microkernel and OS design. It targets tightly
integrated, high-end embedded systems and it has an emphasis on the ARM
architecture.

It is quite common to see open source projects developed in a closed-doors
fashion. Codezero project goes beyond just publishing source code as open source
but also uses the latest open source development practices such as those used by
the Linux Kernel.


Why the name Codezero?

The project focuses on simplicity, elegance and cleanliness. The philosophy is
to implement structurally advanced software while retaining simplicity in the
design. Also the project is written from scratch, so the name emphasises that.


Design & Features:

Based on L4 microkernel principles, there are only a few system calls in
Codezero. These system calls provide purely mechanism; threads and address
spaces, and the methods of inter-process communication between them. Anything
beyond these are policy and they are implemented in the userspace. Due to this
rigorously simple design the same microkernel can be used to design completely
different operating systems.

In terms of other features, the microkernel is preemptive, and smp-ready.
Currently only synchronous communication is implemented, but this will change in
the near future.

There are two system tasks built upon the base microkernel that manage memory
and file-based I/O, called MM0 and FS0. MM0 is the system task that implements
memory management. It contains memory and page allocators. It implements demand
paging by managing page faults, physical pages and their file/task associations.
It provides the default paging mechanism on Codezero.

FS0 is the system task that implements a simple, modern virtual filesystem
layer. It is designed to serve file requests from MM0. Since it abstracts the
low-level filesystem details, it is a relatively easy job to port a new
filesystem to be used under FS0.

MM0 and FS0 both reside in the userspace, and they are not mandatory services.
For example the virtual and physical memory resources can be partitioned by
Codezero among pagers, and a third-party pager can override Codezero's pager on
the same run-time, and implement an independent paging behaviour for its own
memory partition. This feature provides the option of having an adjustable
mixture of generalisation and specialisation of system services at the same
run-time, by using a combination of Codezero's abstract posix-like page/file
management services and an application-specific pager that depends on its own
paging abilities. For example a critical task could both use mm0 and fs0's
posix-like files benefiting from the abstraction and simplification that it
brings, but at the same time rely on its own page-fault handling for its
critical data so that even though it handles its memory in a specialised way,
it does not depend on another pager's grace for correct, stable operation.
Similarly, a whole operating system can be virtualised and both native and
virtualised applications can run on the same run-time.


License:

The current 'Toy' release is distributed under GNU General Public License
Version 3 and this version only. Any next version will be released in the same
license, but there are intentions to keep the project in a dual-licensed manner.
In any case, the project source code will always be released as open source as
in the OSI definition.

The third party source code under the directories loader/ tools/ libs/c libs/elf
have their own copyright and licenses, separate from this project. All third
party source code is open source in the OSI definition. Please check these
directories for their respective licenses.


Why yet another POSIX microkernel?

There are many open source POSIX operating systems with advanced features such
as BSD versions and Linux. However, neither of these were originally designed
for embedded systems. Multiple problems arise due to this fact.

Unix itself and all the tools built upon weren't meant for using on small
devices. Accordingly, existing Unix operating systems contain a lot of
historical code. Their code base is so big, that it gets more and more difficult
to understand how their internals work. On these systems usually much of the
existing code base is irrelevant to newly developed software, and embedded
systems need new software often. Codezero is written from scratch to solely
target embedded systems and as such the source code is %100 relevant. It is
small and free from legacy code.

From a design perspective, these kernels have a monolithic design, and as such
they may have issues with dependability due to much of the code sharing the same
address space. This is an important issue on embedded systems since their
operation is more sensitive to disruptions. Being a microkernel design, Codezero
aims to defeat this problem and increase dependability.

From a support perspective, most Unix operating systems like BSD and linux have
a highly saturated user base. The developers focus on these existing users and
often the systems they support are servers and not embedded computers. Codezero
will focus completely on embedded systems, aiming to meet the support need for
this type of systems.

Other than modern unix kernels, there are existing operating systems targeting
embedded devices. Most of them are proprietary, with their own users. Some of
them are structurally too simplistic, and lack modern features such as paging.
There ones that are well established, but Codezero will contrast them by
being a more open alternative. Many embedded software projects still use older
or closed development methods and the right open source methodology would prove
favorable in the fast-paced nature of embedded software development.

Finally, POSIX compliance is only a step, or a partial aim for the Codezero
microkernel. It is not limited to the goal of just complying with POSIX, which
has been done many times by other operating systems. The idea is to implement
a generic software environment where multiple system services can reside in
the same run-time, but on the other hand, native system services will be
supplied as the default solution. In other words, the project will provide the
mechanism to accomodate multiple operating systems, and it will also supply its
own set of system services with a POSIX-like API. By providing a variety of
system software options, the applications will be able to choose among different
speed, safety, determinism policies at the same run-time. This is expected to
prove useful in the embedded software domain.

Furthermore there are new ideas in literature that would improve systems
software but aren't implemented either because they have no existing users or
may break compatibility (e.g. some are presented in Plan 9). For example file
abstractions could be used more liberally to cover data exchange and control of
devices, services and network communication. Existing kernels already have
established methods of doing such operations and they would oppose major design
overhauls, which limits their innovation capability for this kind of
experimentation. As well as practising realistic development strategies such as
native POSIX support, Codezero project aims to keep up with the latest OS
literature and provide the opportunity to incorporate the latest ideas in OS
technology.


Can you summarise all this? Why should I use Codezero, again?

Codezero is an operating system that targets embedded systems. It supports the
most fundamental POSIX calls and it implements modern features such as
demand-paging and virtual filesystem layer. Different from most other posix-like
systems, it is based on a microkernel design. This makes it possible to use it
also as a base for implementing or running other operating systems. It has a
cleanly separated set of system services, it is small and well-focused. Its
design is carefully thought out, so it's not simply a quick and dirty
implementation of the POSIX API. Its source code is also freely available (See
LICENSE heading for details). For these reasons it is a good candidate to be
used as systems software on embedded platforms. Currently it has little or no
users, therefore it can be easily adopted for any first users' needs.


