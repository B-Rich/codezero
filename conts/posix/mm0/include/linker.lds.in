/*
 * Simple linker script for userspace or svc tasks.
 *
 * Copyright (C) 2007 Bahadir Balban
 */

/*
 * The only catch with this linker script is that everything
 * is linked starting at virtual_base, and loaded starting
 * at physical_base. virtual_base is the predefined region
 * of virtual memory for userland applications. physical_base
 * is determined at build-time, it is one of the subsequent pages
 * that come after the kernel image's load area.
 */
/* INITTASK_AREA_START, see memlayout.h */
virtual_base = 0xE0000000;
physical_base = %s;

/* INCLUDE "include/physical_base.lds" */

/* physical_base = 0x228000; */
pager_offset = virtual_base - physical_base;

ENTRY(_start)

SECTIONS
{
	. = virtual_base;
	_start_text = .;
	.text : AT (ADDR(.text) - pager_offset) { *(.text.head) *(.text) }
	/* rodata is needed else your strings will link at physical! */
	.rodata : AT (ADDR(.rodata) - pager_offset) { *(.rodata) }
	.rodata1 : AT (ADDR(.rodata1) - pager_offset) { *(.rodata1) }
	.data : AT (ADDR(.data) - pager_offset) { *(.data) }
	.bss : AT (ADDR(.bss) - pager_offset) { *(.bss) }
	. = ALIGN(4K);
	. += 0x2000;	/* BSS doesnt increment link counter??? */
	.stack : AT (ADDR(.stack) - pager_offset)
	{
		*(.stack)
	}
	. = ALIGN(4K);
	__stack = .; /* This is the preallocated boot stack */

	/* Below part is to be discarded after boot */
	_start_init = .;
	.init : AT (ADDR(.init) - pager_offset)
	{
		*(.init.data)
		*(.init.bootmem)
	}
	_end_init = .;
	_end = .;
}
